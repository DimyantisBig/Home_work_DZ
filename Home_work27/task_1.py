# Определяем класс Node, который представляет узел дерева
class Node:
    def __init__(self, data):
        # Инициализация узла с данными
        self.left = None  # Левый потомок (изначально пустой)
        self.right = None  # Правый потомок (изначально пустой)
        self.data = data  # Данные, хранящиеся в узле

    def insert(self, data):
        # Метод для вставки нового значения в дерево
        if self.data:  # Если узел содержит данные
            if data < self.data:  # Если вставляемое значение меньше текущего
                if self.left is None:  # Если левый потомок пуст
                    self.left = Node(data)  # Создаем новый узел слева
                else:  # Если левый потомок уже существует
                    self.left.insert(data)  # Рекурсивно вставляем значение в левое поддерево
            elif data > self.data:  # Если вставляемое значение больше текущего
                if self.right is None:  # Если правый потомок пуст
                    self.right = Node(data)  # Создаем новый узел справа
                else:  # Если правый потомок уже существует
                    self.right.insert(data)  # Рекурсивно вставляем значение в правое поддерево
        else:  # Если текущий узел пуст (в корне нет данных)
            self.data = data  # Присваиваем новое значение текущему узлу

    def insert_tree(self, root):
        # Метод для вставки целого дерева в текущее дерево
        if self.data is None:  # Если текущее дерево пусто
            self = root  # Просто заменяем текущее дерево на новое
        else:
            # Находим самый правый узел текущего дерева
            node = self
            while node.right:  # Пока существует правый потомок
                node = node.right  # Переходим к правому узлу
            node.right = root  # Присоединяем новое дерево к самому правому узлу

    def delete_subtree(self, data):
        # Метод для удаления поддерева
        if self.data == data:  # Если текущий узел равен удаляемому значению
            return None  # Удаляем узел, возвращая None
        else:
            # Если текущий узел не совпадает, проверяем левого потомка
            if self.left:
                self.left = self.left.delete_subtree(data)  # Рекурсивно удаляем в левом поддереве
            # Проверяем правого потомка
            if self.right:
                self.right = self.right.delete_subtree(data)  # Рекурсивно удаляем в правом поддереве
        return self  # Возвращаем текущий узел (если он не удален)

# Создаем корневой узел дерева
root = Node(10)  # Узел с корневым значением 10
root.insert(6)  # Вставляем значение 6
root.insert(14)  # Вставляем значение 14

# Создаем второе дерево
new_tree = Node(8)  # Корень второго дерева со значением 8
new_tree.insert(7)  # Вставляем значение 7
new_tree.insert(9)  # Вставляем значение 9

# Вставляем второе дерево в основное дерево
root.insert_tree(new_tree)

# Удаляем поддерево с корнем 6
root = root.delete_subtree(6)

"""
Пояснения
Класс Node: Представляет один узел в дереве.
Метод insert: Рекурсивно добавляет новый элемент в дерево, соблюдая порядок.
Метод insert_tree: Вставляет все дерево в текущее, прикрепляя его к самому правому узлу. 
Это упрощенный подход, можно реализовать более сложные стратегии вставки.
Метод delete_subtree: Рекурсивно удаляет поддерево, начиная с указанного узла.
"""

"""
Важно!
Повторить тему!Частично не понятно.
"""
